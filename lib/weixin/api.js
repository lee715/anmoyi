// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, WXPay, WX_API, _, async, body, config, db, detail, generateWxSign, host, ip, key, mch_id, mpAPI, qs, redis, ref, ref1, request, total_fee, u, urlType, wx_date, wxpay;

  _ = require('lodash');

  qs = require('qs');

  config = require('config');

  async = require('async');

  request = require('request');

  urlType = require('./url');

  redis = require('../services/redis');

  mpAPI = require('./mpApi');

  db = require('limbo').use('anmoyi');

  Promise = require('bluebird');

  ref = require('config').wxConfig, mch_id = ref.mch_id, body = ref.body, detail = ref.detail, total_fee = ref.total_fee, key = ref.key;

  ref1 = require('config'), ip = ref1.ip, host = ref1.host;

  u = require('../services/util');

  request = require('request');

  WXPay = require('weixin-pay');

  wxpay = WXPay({
    appid: config.MP_WEIXIN.appid,
    mch_id: mch_id,
    partner_key: key
  });

  wx_date = function(date) {
    var str;
    if (date) {
      date = new Date(date);
    } else {
      date = new Date;
    }
    str = date.toJSON();
    return str.replace(/-|T|:|.\d{3}Z/g, '');
  };

  generateWxSign = function(data) {
    var qsStr;
    qsStr = u.qsParseSortByAscii(data);
    qsStr += "&key=" + key;
    return u.md5(qsStr).toUpperCase();
  };

  module.exports = WX_API = {
    getAccessToken: function() {
      return function(req, res, next) {
        var fields, query;
        if (!req.query.code) {
          return next('codeNotFound');
        }
        fields = ['appid', 'secret', 'grant_type'];
        query = _.pick(config.WX_OPEN_PLATFORM, fields);
        query.code = req.query.code;
        if (req.isMP) {
          _.assign(query, _.pick(config.MP_WEIXIN, ['appid', 'secret']));
        }
        query = qs.stringify(query);
        return request.get({
          url: urlType.getWXTokenURL(query),
          timeout: 5000,
          json: true
        }, function(err, resp, body) {
          if (err) {
            console.log(err);
          }
          if ((body != null ? body.errcode : void 0) === 40029) {
            return next('unbindError');
          }
          if (err || (body != null ? body.errcode : void 0)) {
            return next('wxAPIError');
          }
          req.weixin_auth = {
            body: body
          };
          return next();
        });
      };
    },
    getUserInfo: function(arg, callback) {
      var access_token, isMP, openid, self;
      access_token = arg.access_token, openid = arg.openid, isMP = arg.isMP;
      self = this;
      return async.waterfall([
        function(next) {
          if (isMP) {
            return mpAPI.getMPToken(next);
          } else {
            return next();
          }
        }
      ], function(err, token) {
        var query;
        if (err) {
          return callback(err);
        }
        query = qs.stringify({
          access_token: token || access_token,
          openid: openid
        });
        return request.get({
          url: urlType.userInfoURL(query, isMP),
          timeout: 5000,
          json: true
        }, function(err, resp, body) {
          if (err) {
            console.log(err);
          }
          if (err || (body != null ? body.errcode : void 0)) {
            return callback('wxAPIError');
          }
          return callback(null, body);
        });
      });
    },
    sendMessage: function(touser, content) {
      return this._getAccessToken(function(err, access_token) {
        if (err) {
          return;
        }
        return request.post({
          headers: {
            'content-type': 'application/json'
          },
          url: urlType.messageURL("access_token=" + access_token),
          timeout: 5000,
          body: JSON.stringify({
            touser: touser,
            text: {
              content: content
            },
            msgtype: 'text'
          })
        }, function(err, resp, body) {
          if (err) {
            return console.log(err);
          }
        });
      });
    },
    sendTemplateMessage: function(content) {
      return mpAPI.getMPToken(function(err, access_token) {
        if (err) {
          return;
        }
        return request.post({
          headers: {
            'content-type': 'application/json'
          },
          url: urlType.getSendTemplateMsgURL("access_token=" + access_token),
          timeout: 5000,
          body: JSON.stringify(content)
        }, function(err, res, body) {});
      });
    },
    getUserInfo: function(openid, callback) {
      var self;
      self = this;
      return async.waterfall([
        function(next) {
          return self._getAccessToken(next);
        }, function(access_token, next) {
          var query;
          query = qs.stringify({
            access_token: access_token,
            openid: openid
          });
          return request.get({
            url: urlType.openIdURL(query),
            timeout: 5000,
            json: true
          }, function(err, resp, body) {
            if (err || (body != null ? body.errcode : void 0)) {
              return next('wxAPIError');
            }
            return next(null, body);
          });
        }
      ], callback);
    },
    _getAccessToken: function(callback) {
      return redis.get(config.MP_WEIXIN.tokenKey, function(err, resp) {
        if (err) {
          return callback('redisError');
        }
        return callback(null, resp);
      });
    },
    checkSingle: function(message, callback) {
      var _id, rkey;
      _id = message.msgid;
      if (!_id) {
        _id = message.fromusername + ":" + message.createtime;
      }
      rkey = "WEIXIN:SINGLE:ID:" + _id;
      return async.waterfall([
        function(next) {
          return redis.get(rkey, function(err, resp) {
            if (err) {
              return next('redisError');
            }
            if (resp) {
              return next('messageExist');
            }
            return next();
          });
        }, function(next) {
          return redis.set(rkey, JSON.stringify(message), function(err) {
            if (err) {
              return next('redisError');
            }
            return next();
          });
        }
      ], callback);
    },
    getViewUrl: function(options) {
      var _scope, projectViews;
      if (options == null) {
        options = {};
      }
      _scope = options.scope || 'snsapi_base';
      projectViews = qs.stringify({
        appid: config.MP_WEIXIN.appid,
        redirect_uri: config.MP_WEIXIN.codeURL,
        response_type: 'code',
        scope: _scope,
        state: options.state || config.MP_WEIXIN.state
      });
      return urlType.getMPAuthURL(projectViews) + "#wechat_redirect";
    },
    createMenu: function() {
      var buttons, self;
      self = this;
      buttons = config.WX_OPEN_PLATFORM.buttons;
      return async.waterfall([
        function(next) {
          return self._getAccessToken(next);
        }, function(access_token, next) {
          var query, url;
          query = qs.stringify({
            access_token: access_token
          });
          url = urlType.menuURL + "?" + query;
          return request({
            url: url,
            timeout: 5000,
            method: 'POST',
            body: buttons,
            json: true
          }, function(err, resp, body) {
            if (err || (body != null ? body.errcode : void 0)) {
              return next('wxAPIError');
            }
            return next(null, body);
          });
        }
      ], function(err, body) {
        if (err) {
          return console.log(err);
        }
      });
    },
    unifiedorder: function(product_id, open_id, callback) {
      return wxpay.createUnifiedOrder({
        device_info: 'WEB',
        nonce_str: u.v4(),
        body: body,
        detail: detail || '',
        out_trade_no: product_id,
        total_fee: total_fee,
        spbill_create_ip: ip,
        time_start: wx_date(),
        notify_url: host + "/wx/notify",
        trade_type: "NATIVE",
        product_id: product_id,
        openid: open_id
      }, function(err, res) {
        return callback(err, res);
      });
    },
    getBrandWCPayRequestParams: function(open_id, order, cost, callback) {
      return wxpay.getBrandWCPayRequestParams({
        body: body,
        detail: detail || '',
        out_trade_no: order,
        total_fee: cost,
        spbill_create_ip: ip,
        notify_url: host + "/wx/notify",
        openid: open_id
      }, function(err, res) {
        return callback(err, res);
      });
    },
    h5pay: function(prepay_id) {
      var data;
      data = {
        appId: appid,
        timeStamp: wx_date(),
        nonceStr: u.v4(),
        "package": prepay_id,
        signType: "MD5"
      };
      data.paySign = generateWxSign(data);
      return u.qsParseSortByAscii(data);
    },
    getPayInfo: function(openid, callback) {
      return redis.getAsync("PAYINFO." + openid).then(function(uid) {
        return db.device.findOneAsync({
          uid: uid
        });
      }).then(function(device) {
        var info;
        info = device.getPayInfo();
        return callback(null, info);
      })["catch"](callback);
    },
    useWXCallback: wxpay.useWXCallback,
    queryOrder: function() {
      return wxpay.queryOrder.apply(wxpay, arguments);
    }
  };

  Promise.promisifyAll(WX_API);

}).call(this);
