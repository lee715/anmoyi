// Generated by CoffeeScript 1.10.0
(function() {
  var MP_API, Promise, _, async, config, crypto, qs, redis, request, urlType, uuid;

  _ = require('lodash');

  qs = require('qs');

  config = require('config');

  async = require('async');

  uuid = require('uuid');

  crypto = require('crypto');

  request = require('request');

  urlType = require('./url');

  redis = require('../services/redis');

  Promise = require('bluebird');

  module.exports = MP_API = {
    refreshTicket: function(callback) {
      var expires, self;
      if (callback == null) {
        callback = function() {};
      }
      self = this;
      expires = [];
      return async.waterfall([
        function(next) {
          return self._getMPToken(next);
        }, function(res, next) {
          var access_token, expires_in;
          access_token = res.access_token, expires_in = res.expires_in;
          expires.push(expires_in);
          return self._getTicket(access_token, next);
        }
      ], function(err, res) {
        var expires_in;
        if (err) {
          return callback(err);
        }
        expires_in = res.expires_in;
        expires.push(expires_in);
        return callback(null, Math.min.apply(Math, expires));
      });
    },
    getTicket: function(url, callback) {
      if (typeof url === 'function') {
        callback = url;
        url = null;
      }
      return redis.get(config.MP_WEIXIN.ticketKey, function(err, ticket) {
        var noncestr, ret, signature_list, timestamp;
        if (err) {
          return callback('redisError');
        }
        if (!ticket) {
          return callback('ticketNotFound');
        }
        noncestr = uuid.v4().split('-').join('');
        timestamp = Math.floor(Date.now() / 1000);
        signature_list = ["jsapi_ticket=" + ticket, "noncestr=" + noncestr, "timestamp=" + timestamp, "url=" + (url || config.MP_WEIXIN.JSSDK_URL)];
        ret = {
          noncestr: noncestr,
          timestamp: timestamp,
          signature: crypto.createHash('sha1').update(signature_list.join('&')).digest('hex')
        };
        return callback(null, ret);
      });
    },
    getQrcodeTicket: function(scenes, callback) {
      var self;
      self = this;
      return async.waterfall([
        function(next) {
          return self.getMPToken(next);
        }, function(access_token, next) {
          return request.post({
            headers: {
              'content-type': 'application/json'
            },
            url: urlType.qrcodeURL("access_token=" + access_token),
            timeout: 5000,
            body: JSON.stringify({
              action_name: 'QR_LIMIT_STR_SCENE',
              action_info: {
                scene: {
                  scene_str: scenes
                }
              }
            })
          }, function(err, res, body) {
            if (err) {
              log.error(err);
            }
            return next(err, JSON.parse(body));
          });
        }
      ], callback);
    },
    getUserInfoToken: function(code, callback) {
      var fields, params, query;
      fields = ['appid', 'secret'];
      params = _.pick(config.MP_WEIXIN, fields);
      params.code = code;
      params.grant_type = 'authorization_code';
      query = qs.stringify(params);
      return request.get({
        url: urlType.getWXTokenURL(query),
        timeout: 5000,
        json: true
      }, function(err, resp, body) {
        var access_token, expires_in, openid;
        if (err) {
          log.error(err);
          return callback('wxAPIError');
        }
        access_token = body.access_token, expires_in = body.expires_in, openid = body.openid;
        return callback(err, access_token, openid);
      });
    },
    getUserInfo: function(token, openid, callback) {
      var fields, query;
      fields = {
        'access_token': token,
        'openid': openid
      };
      console.log("MP_API:getUserInfo:fields", fields);
      query = qs.stringify(fields);
      return request.get({
        url: urlType.userInfoURL(query),
        timeout: 5000,
        json: true
      }, function(err, resp, body) {
        var nickname, unionid, userid;
        console.log(err, body);
        if (err || (body != null ? body.errcode : void 0)) {
          return callback('wxAPIError');
        }
        openid = body.openid, nickname = body.nickname, unionid = body.unionid;
        if (unionid) {
          userid = unionid;
        } else {
          userid = openid;
        }
        return callback(err, body);
      });
    },
    getMPToken: function(callback) {
      return redis.get(config.MP_WEIXIN.tokenKey, callback);
    },
    _getMPToken: function(callback) {
      var fields, query;
      fields = ['appid', 'secret', 'grant_type'];
      query = qs.stringify(_.pick(config.MP_WEIXIN, fields));
      return request.get({
        url: urlType.getMPTokenURL(query),
        timeout: 5000,
        json: true
      }, function(err, resp, body) {
        var access_token, expires_in;
        if (err) {
          log.error(err);
        }
        if (err || (body != null ? body.errcode : void 0)) {
          return callback('wxAPIError');
        }
        access_token = body.access_token, expires_in = body.expires_in;
        console.log("access_token", access_token);
        redis.set(config.MP_WEIXIN.tokenKey, access_token);
        redis.expire(config.MP_WEIXIN.tokenKey, expires_in);
        return callback(null, body);
      });
    },
    _getTicket: function(access_token, callback) {
      var query;
      query = qs.stringify({
        access_token: access_token,
        type: 'jsapi'
      });
      return request.get({
        url: urlType.ticketURL(query),
        timeout: 5000,
        json: true
      }, function(err, resp, body) {
        var expires_in, ticket;
        if (err) {
          log.error(err);
        }
        if (err || (body != null ? body.errcode : void 0)) {
          return callback('wxAPIError');
        }
        ticket = body.ticket, expires_in = body.expires_in;
        redis.set(config.MP_WEIXIN.ticketKey, ticket);
        redis.expire(config.MP_WEIXIN.ticketKey, expires_in);
        return callback(null, body);
      });
    },
    setupMpTicket: function(callback) {
      var doRefresh, self;
      self = this;
      doRefresh = function() {
        return self.refreshTicket(function(err, expires) {
          if (err) {
            return callback(err);
          }
          return setTimeout(doRefresh, expires * 1000 - 5000);
        });
      };
      return doRefresh();
    }
  };

  Promise.promisifyAll(MP_API);

}).call(this);
