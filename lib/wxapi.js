// Generated by CoffeeScript 1.10.0
(function() {
  var API, MP_API, Promise, WXPay, WX_API, _, async, db, queryOrderByTimes, queryOrderByTimesAsync, redis, sockSrv, wxReply;

  _ = require('lodash');

  db = require('limbo').use('anmoyi');

  WX_API = require('./weixin/api');

  MP_API = require('./weixin/mpApi');

  WXPay = require('weixin-pay');

  async = require('async');

  wxReply = require('./weixin/message');

  redis = require('./services/redis');

  Promise = require('bluebird');

  sockSrv = require('./services/socket');

  queryOrderByTimes = function(_orderId, times, callback) {
    var _doOne;
    _doOne = function() {
      return WX_API.queryOrder({
        out_trade_no: "" + _orderId
      }, function(err, wx_order) {
        console.log('times', times, wx_order.trade_state);
        if (wx_order.trade_state !== 'SUCCESS') {
          times--;
          if (times > 0) {
            return setTimeout(_doOne, 1000);
          } else {
            return callback(null, false);
          }
        } else {
          return callback(null, true);
        }
      });
    };
    return _doOne();
  };

  queryOrderByTimesAsync = Promise.promisify(queryOrderByTimes);

  API = (function() {
    "响应微信消息";
    function API() {}

    API.prototype.handleMessage = function(req, callback) {
      var _message;
      _message = req._message;
      async.waterfall([
        function(next) {
          return WX_API.checkSingle(_message, next);
        }
      ], function(err) {
        return wxReply(_message);
      });
      return callback(null, '');
    };

    API.prototype.handleMessage.route = ['post', '/wx/message'];

    API.prototype.handleMessage.before = [
      function(req, res, next) {
        var key, message, msg, val;
        message = req.body.xml;
        msg = {};
        for (key in message) {
          val = message[key];
          msg[key] = val != null ? val[0] : void 0;
        }
        req._message = msg;
        return next();
      }
    ];

    API.prototype.payTestView = function(req, callback) {
      var openid;
      openid = req.query.openid;
      return WX_API.getPayInfoAsync(openid).then(function(info) {
        return db.place.findOneAsync({
          _id: info._placeId
        }).then(function(place) {
          info.placeName = place.name;
          return info;
        });
      }).then(function(info) {
        var ref;
        info.openid = openid;
        if ((ref = info.status) === 'idle' || ref === 'work') {
          return db.order.createAsync({
            money: info.cost,
            time: info.time,
            openId: openid,
            deviceStatus: info.status,
            uid: info.uid,
            _userId: info._userId,
            _placeId: info._placeId,
            mode: "WX"
          }).then(function(order) {
            return WX_API.getBrandWCPayRequestParamsAsync(openid, "" + order._id, info.cost).then(function(args) {
              info.payargs = args;
              info.order = "" + order._id;
              return req.res.render('pay', info);
            });
          });
        } else {
          info.payargs = {};
          return req.res.render('pay', info);
        }
      })["catch"](function() {
        return req.res.send('system error, please try later');
      });
    };

    API.prototype.payTestView.route = ['get', '/view/test/h5pay'];

    API.prototype.payView = function(req, callback) {
      var openid;
      openid = req.query.openid;
      return WX_API.getPayInfoAsync(openid).then(function(info) {
        return db.place.findOneAsync({
          _id: info._placeId
        }).then(function(place) {
          info.placeName = place.name;
          return info;
        });
      }).then(function(info) {
        var ref;
        info.openid = openid;
        if ((ref = info.status) === 'idle' || ref === 'work') {
          return db.order.createAsync({
            money: info.cost,
            time: info.time,
            openId: openid,
            deviceStatus: info.status,
            uid: info.uid,
            _userId: info._userId,
            _placeId: info._placeId,
            mode: "WX"
          }).then(function(order) {
            return WX_API.getBrandWCPayRequestParamsAsync(openid, "" + order._id, info.cost * 100).then(function(args) {
              info.payargs = args;
              info.order = "" + order._id;
              return req.res.render('pay', info);
            });
          });
        } else {
          info.payargs = {};
          return req.res.render('pay', info);
        }
      })["catch"](function() {
        return req.res.send('system error, please try later');
      });
    };

    API.prototype.payView.route = ['get', '/pay/v1/h5pay'];

    API.prototype.confirmAndStart = function(req, callback) {
      var _orderId, openid, order, ref, uid;
      ref = req.query, _orderId = ref._orderId, uid = ref.uid, openid = ref.openid;
      console.log('confirmAndStart', _orderId, uid, openid);
      if (!(uid && _orderId)) {
        return callback(new Error('paramErr'));
      }
      order = null;
      return db.order.findOneAsync({
        _id: _orderId
      }).then(function(_order) {
        order = _order;
        if (order.status !== 'SUCCESS') {
          return queryOrderByTimesAsync(order._id, 3).then(function(state) {
            console.log('state', state);
            if (!state) {
              throw new Error('confirm failed');
            }
          });
        }
      }).then(function() {
        order.status = "SUCCESS";
        order.serviceStatus = 'PAIED';
        return order.saveAsync();
      }).then(function() {
        return redis.getAsync("ORDER.COMMAND.LOCK." + _orderId);
      }).then(function(lock) {
        if (lock) {
          throw new Error('order is handling');
        }
        return redis.setexAsync("ORDER.COMMAND.LOCK." + _orderId, 60 * 10, 1);
      }).then(function() {
        return sockSrv.startAsync(uid, order.time).then(function(state) {
          if (!state) {
            throw new Error('start failed');
          }
          order.serviceStatus = 'STARTED';
          return order.saveAsync();
        }).then(function() {
          return db.device.updateAsync({
            uid: uid
          }, {
            status: 'work'
          }, {
            upsert: false,
            "new": false
          });
        }).then(function() {
          return callback(null, 'ok');
        });
      }).then(function() {
        return redis.del("ORDER.COMMAND.LOCK." + _orderId);
      })["catch"](function(e) {
        console.log(e.stack);
        return callback(e);
      });
    };

    API.prototype.confirmAndStart.route = ['get', '/wx/order/run'];

    API.prototype.orderStatus = function(req, callback) {
      var expect, order;
      order = req.query.order;
      expect = req.query.expect;
      if (!order) {
        return callback(new Error('order is required'));
      }
      return db.order.findOneAsync({
        _id: order
      }).then(function(order) {
        if (expect && order.status !== expect) {
          return WX_API.queryOrderAsync({
            out_trade_no: "" + order._id
          }).then(function(wx_order) {
            if (wx_order.trade_state !== order.status) {
              order.status = wx_order.trade_state;
              if (wx_order.trade_state === 'SUCCESS') {
                order.serviceStatus = "PAIED";
              }
              order.save();
            }
            return wx_order.trade_state;
          });
        } else {
          return order.status;
        }
      }).then(function(status) {
        return callback(null, status);
      })["catch"](function(e) {
        console.log(e);
        return callback(e);
      });
    };

    API.prototype.orderStatus.route = ['get', '/wx/order/status'];

    return API;

  })();

  module.exports = new API;

}).call(this);
