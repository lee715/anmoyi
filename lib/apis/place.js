// Generated by CoffeeScript 1.10.0
(function() {
  var API, _, db, moment, u, userSrv;

  _ = require('lodash');

  db = require('limbo').use('anmoyi');

  u = require('../services/util');

  userSrv = require('../services/user');

  moment = require('moment');

  API = (function() {
    function API() {}

    API.prototype.create = function(req, callback) {
      var email;
      email = req.body.email;
      if (!email) {
        return req.res.status(302).send('paramErr');
      }
      return db.place.findOneAsync({
        email: email
      }).then(function(place) {
        if (place) {
          return req.res.status(302).send('emailUsed');
        } else {
          return db.place.createAsync(req.body).then(function(place) {
            return callback(null, place.toJSON());
          });
        }
      });
    };

    API.prototype.create.route = ['post', '/places'];

    API.prototype.create.before = [userSrv.isRoot];

    API.prototype.delPlace = function(req, callback) {
      var _id;
      _id = req.body._id;
      return db.place.remove({
        _id: _id
      }, callback);
    };

    API.prototype.delPlace.route = ['delete', '/places'];

    API.prototype.update = function(req, callback) {
      var email;
      email = req.body.email;
      delete req.body._id;
      delete req.body.email;
      return db.place.findOneAndUpdate({
        email: email
      }, req.body, {
        upsert: false,
        "new": false
      }, callback);
    };

    API.prototype.update.route = ['put', '/places'];

    API.prototype.update.before = [userSrv.isRoot];

    API.prototype.get = function(req, callback) {
      var cons, user;
      user = req._data.user;
      if (user.role === 'root') {
        cons = {};
      } else {
        cons = {
          _agentId: user._id
        };
      }
      return db.place.findAsync(cons).then(function(places) {
        return callback(null, _.map(places, function(place) {
          return place.format();
        }));
      });
    };

    API.prototype.get.route = ['get', '/places'];

    API.prototype.get.before = [userSrv.isAgent];

    API.prototype.getPlacesWithStatistic = function(req, callback) {
      var cons, user;
      user = req._data.user;
      if (user.role === 'root') {
        cons = {};
      } else {
        cons = {
          _agentId: user._id
        };
      }
      return db.place.findAsync(cons).map(function(place) {
        place = place.format();
        return db.device.findAsync({
          _placeId: place._id
        }).then(function(devices) {
          var lastMonth, lastWeek, now, thisMonth, thisWeek, today, yestoday;
          place.device = {};
          place.device.total = devices.length;
          place.device.normal = 0;
          devices.forEach(function(device) {
            var ref;
            if ((ref = device.realStatus) === 'idle' || ref === 'work') {
              return place.device.normal++;
            }
          });
          now = new Date;
          today = moment().startOf('day').toDate();
          yestoday = moment().add(-1, 'day').startOf('day').toDate();
          thisWeek = moment().startOf('isoWeek').toDate();
          lastWeek = moment().add(-1, 'week').startOf('isoWeek').toDate();
          thisMonth = moment().startOf('month').toDate();
          lastMonth = moment().add(-1, 'month').startOf('month').toDate();
          return [[now, today], [today, yestoday], [now, thisWeek], [thisWeek, lastWeek], [now, thisMonth], [thisMonth, lastMonth]];
        }).map(function(arg) {
          var from, to;
          to = arg[0], from = arg[1];
          return db.order.findAsync({
            created: {
              $gt: from,
              $lt: to
            },
            _placeId: place._id,
            status: 'SUCCESS',
            serviceStatus: {
              $in: ['STARTED', 'ENDED']
            }
          }).then(function(orders) {
            var moneys, total;
            moneys = _.pluck(orders, 'money');
            return total = _.reduce(moneys, function(a, b) {
              return a + b;
            }) || 0;
          });
        }).then(function(moneys) {
          place.moneys = moneys;
          return place;
        });
      }).then(function(places) {
        return callback(null, places);
      })["catch"](function(e) {
        return console.log(e.stack);
      });
    };

    API.prototype.getPlacesWithStatistic.route = ['get', '/places/statistic'];

    API.prototype.getPlacesWithStatistic.before = [userSrv.isAgent];

    API.prototype.getById = function(req, callback) {
      var _id;
      _id = req.params._id;
      return db.place.findOneAsync({
        _id: _id
      }).then(function(place) {
        return callback(null, place && place.format());
      });
    };

    API.prototype.getById.route = ['get', '/places/:_id'];

    API.prototype.getById.before = [userSrv.isLogined];

    API.prototype.reconciliation = function(req, callback) {
      var _placeId, p, ref, user;
      user = req._data.user;
      _placeId = req.params._placeId;
      if (!(((ref = user.role) === 'agent' || ref === 'place' || ref === 'root') && _placeId)) {
        return res.status(403).send('Forbidden');
      }
      p = null;
      return db.place.findOneAsync({
        _id: _placeId
      }).then(function(place) {
        var months, ref1;
        p = place.p;
        if ((user.role === 'agent' && ("" + place._agentId) === ("" + user._id)) || ((ref1 = user.role) === 'place' || ref1 === 'root')) {
          return months = [[moment().startOf('month'), moment().startOf('day')], [moment().startOf('month').add(-1, 'month'), moment().startOf('month')], [moment().startOf('month').add(-1, 'month'), moment().startOf('month').add(-2, 'month')]];
        } else {
          return [];
        }
      }).map(function(arg) {
        var end, start;
        start = arg[0], end = arg[1];
        return db.order.findAsync({
          _placeId: _placeId,
          status: 'SUCCESS',
          serviceStatus: 'STARTED',
          mode: 'WX',
          created: {
            $gt: start.toDate(),
            $lt: end.toDate()
          }
        }).then(function(orders) {
          var total;
          total = 0;
          orders.forEach(function(order) {
            return total += +order.money;
          });
          return (total * p / 100).toFixed(2);
        });
      }).then(function(totals) {
        return callback(null, totals);
      });
    };

    API.prototype.reconciliation.route = ['get', '/reconciliation/:_placeId'];

    API.prototype.reconciliation.before = [userSrv.isLogined];

    return API;

  })();

  module.exports = new API;

}).call(this);
