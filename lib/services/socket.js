// Generated by CoffeeScript 1.9.1
(function() {
  var PORT, SERVICES, SOCKS, STATUS_VALS, TbService, _, config, db, incomeSrv, moment, net, recordStatus, updateDevice;

  net = require('net');

  config = require('config');

  PORT = config.SOECKET_PORT || '7000';

  db = require('limbo').use('anmoyi');

  _ = require('lodash');

  incomeSrv = require('./income');

  moment = require('moment');

  updateDevice = function(uid, status, income, wxTime) {
    console.log('updateDevice', uid, status, income, wxTime);
    return db.device.findOneAsync({
      uid: uid
    }).then(function(device) {
      if (device) {
        console.log('device matched and update now ' + uid);
        device.status = status;
        device.income = income;
        device.wxTime = wxTime;
        return device.save();
      }
    });
  };

  TbService = (function() {
    function TbService(uid) {
      this.uid = uid;
      this;
    }

    TbService.prototype.handle = function(action, val) {
      switch (action) {
        case 'timebuy':
          if (!this.times) {
            this.times = [];
            this.start = new Date;
          }
          this.times.push(val);
          SOCKS.resOk(this.uid);
          break;
        case 'cashtotal':
          return this.serviceEnd(val);
      }
    };

    TbService.prototype.serviceEnd = function(cash) {
      var buyTime, end, j, len, order, ref, serviceTime, start, t;
      end = new Date;
      start = this.start;
      serviceTime = end - start;
      buyTime = 0;
      ref = this.times;
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        buyTime += t * 60 * 1000;
      }
      order = {
        money: cash,
        time: buyTime,
        uid: this.uid
      };
      if (buyTime < serviceTime) {
        order.status = 'SUCCESS';
      } else {
        order.status = 'ERROR';
      }
      return db.device.findOneAsync({
        uid: this.uid
      }).then(function(device) {
        order._userId = device._userId;
        order.deviceStatus = device.status;
        return db.order.createAsync(order);
      }).then(function() {
        return SERVICES.remove(this.uid);
      })["catch"](function(e) {
        order.status = "DB_ERROR";
        return db.order.create(order, function() {});
      });
    };

    return TbService;

  })();

  SERVICES = {
    remove: function(uid) {
      return delete this[uid];
    }
  };

  SOCKS = {
    _cbs: {},
    _socks: {},
    resOk: function(uid) {
      var sock;
      sock = this.get(uid);
      if (sock) {
        return sock.write("~" + uid + "#OK\r");
      }
    },
    resSet: function(uid, action, callback) {
      var sock;
      sock = this.get(uid);
      if (sock) {
        this.handleCB(uid, callback);
        return sock.write("~" + uid + "#set#" + action + "\r");
      }
    },
    resStart: function(uid, time, callback) {
      var sock;
      sock = this.get(uid);
      console.log('resStart:sock', uid, time);
      if (sock) {
        this.handleCB(uid, callback);
        return sock.write("~" + uid + "#startup#" + time + "\r");
      }
    },
    handleCB: function(uid, callback) {
      return this._cbs[uid] = (function(_this) {
        return function(state, err) {
          if (state) {
            callback(null, uid);
          } else {
            callback(err);
          }
          return delete _this._cbs[uid];
        };
      })(this);
    },
    cacheSock: function(uid, sock) {
      if (uid && sock) {
        return this._socks[uid] = sock;
      }
    },
    get: function(uid) {
      return this._socks[uid];
    },
    handleMsg: function(msg, sock) {
      var action, arr, status, tbCount, uid, val, wxTime;
      if (!/^\~/.test(msg)) {
        return;
      }
      msg = msg.replace(/[^0-9a-zA-Z\#]+/g, '');
      arr = msg.split('#');
      if (arr.length < 3) {
        return;
      }
      this.cacheSock(arr[0], sock);
      if (this._cbs[uid]) {
        if (arr.length === 3 && arr[2] === 'OK') {
          this._cbs[uid](true);
        } else if (arr.length === 3 && arr[2] !== 'OK') {
          this._cbs[uid](false, arr[1]);
        } else {
          this._cbs[uid](false, 'NO_ANWSER');
        }
      }
      if (arr.length === 3) {
        uid = arr[0], action = arr[1], val = arr[2];
        if (val === 'OK') {
          return;
        }
        if (!SERVICES[uid]) {
          SERVICES[uid] = new TbService(uid);
        }
        return SERVICES[uid].handle(action, val);
      } else if (arr.length > 3) {
        uid = arr[0], tbCount = arr[1], wxTime = arr[2], status = arr[3], val = arr[4];
        status = status.toLowerCase();
        if (status === 'free' || status === 'idle') {
          status = 'idle';
        } else if (status !== 'work') {
          status = 'fault';
        }
        wxTime = +wxTime.slice(1);
        updateDevice(uid, status, tbCount, wxTime);
        recordStatus(uid, status);
        incomeSrv(uid, tbCount, wxTime);
        return SOCKS.resOk(uid);
      }
    }
  };

  STATUS_VALS = {
    idle: "2",
    work: '3',
    fault: "1"
  };

  recordStatus = function(uid, status) {
    var now, start, val;
    val = STATUS_VALS[status] || "9";
    now = new Date;
    start = moment().startOf('day').toDate();
    return db.status.findOneAsync({
      created: start
    }).then(function(status) {
      if (!status) {
        return db.status.createAsync({
          uid: uid,
          created: start
        });
      } else {
        return status;
      }
    }).then(function(one) {
      var i, padded, padding, toAdd;
      padding = parseInt((now - start) / (1000 * 30));
      padded = one.status.length;
      toAdd = val;
      i = padding - padded;
      if (i > 0) {
        while (i--) {
          toAdd = "0" + toAdd;
        }
      }
      one.status += toAdd;
      return one.save();
    });
  };

  net.createServer(function(sock) {
    console.log("CONNECTED: " + sock.remoteAddress + ":" + sock.remotePort);
    sock.on('data', function(data) {
      console.log("DATA: " + data);
      return SOCKS.handleMsg((new Buffer(data)).toString('utf8'), sock);
    });
    return sock.on('close', function() {
      return console.log("CLOSED: " + sock.remoteAddress + ":" + sock.remotePort);
    });
  }).listen(PORT, function() {
    return console.log('Server listening on:' + PORT);
  });

  module.exports = {
    start: function() {
      console.log('socket:start', arguments);
      return SOCKS.resStart.apply(SOCKS, arguments);
    },
    set: function() {
      console.log('socket:set', arguments);
      return SOCKS.resSet.apply(SOCKS, arguments);
    }
  };

}).call(this);
